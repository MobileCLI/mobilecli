# MobileCLI Comprehensive Bug Review & Recommendations

**Date:** 2026-02-15
**Build:** 68 (TestFlight)
**Crash Log:** `/home/bigphoot/Desktop/crashlog.crash`
**Reviewer:** Claude (for Codex)

---

## Table of Contents

1. [Issue #1: Auto-Connect Broken After App Update](#issue-1-auto-connect-broken-after-app-update)
2. [Issue #2: QR Code Puts Auth Token (Shouldn't)](#issue-2-qr-code-auth-token)
3. [Issue #3: Random Crashes](#issue-3-random-crashes)
4. [Issue #4: "Connection Successful" Dialog Stuck](#issue-4-dialog-stuck)
5. [Git History: What Changed After Build 65/66](#git-history-regression-analysis)
6. [Architecture Notes for Context](#architecture-notes)

---

## Issue #1: Auto-Connect Broken After App Update

### Symptom
After updating the mobile app, opening it does not auto-connect. User must run `mobilecli` from a desktop terminal first.

### Root Cause Analysis

**The mobile app DOES auto-connect on mount** (confirmed in code). The problem is multi-layered:

#### A. The daemon has no auto-start mechanism

The CLI daemon (`mobilecli daemon`) only starts when a user explicitly runs `mobilecli` from a terminal. There is no:
- systemd service (Linux)
- launchd plist (macOS)
- Login item / startup script
- Keep-alive mechanism

When the desktop reboots, sleeps, or the daemon crashes, it stays dead. The mobile app's WebSocket connection attempts fail silently and enter exponential backoff (1s -> 30s).

**Relevant code:**
- `cli/src/main.rs:167-173` - Daemon only starts if not running, triggered by CLI invocation
- `cli/src/main.rs:229-291` - `start_daemon_background()` spawns daemon as detached process, but only when `mobilecli` command is run
- No PID keepalive or watchdog exists

#### B. After a CLI update, the old daemon PID may be stale

When the CLI binary is updated (cargo install, git pull+build), the old daemon process may still be running with the old binary. The PID file (`~/.mobilecli/daemon.pid`) points to the old process. If the update kills the old process (or it crashes due to binary incompatibility), the stale PID file prevents `is_running()` from correctly detecting the state.

**Relevant code:**
- `cli/src/daemon.rs:62-74` - `is_running()` reads PID file and calls `is_process_alive()`
- If the process died but the PID file wasn't cleaned up, it returns false and the mobile app can't connect

#### C. Mobile app reconnect backoff masks the issue

When the daemon isn't running, the mobile app's WebSocket connection fails. The reconnect logic uses exponential backoff (1s -> 2s -> 4s -> 8s -> 16s -> 30s cap). After ~8 failed attempts, the reconnect interval is 30 seconds. By the time the user starts the daemon, the mobile app may be waiting 30 seconds before attempting to reconnect.

**Relevant code:**
- `mobile/hooks/useSync.ts:255-274` - `scheduleReconnect()` with exponential backoff capped at 30s
- `mobile/hooks/useSync.ts:748-774` - App resume handler tries to reconnect, but only checks if WebSocket is not open OR heartbeat is stale

### Recommendations

1. **Add daemon auto-start on boot (HIGH PRIORITY)**
   - Linux: Generate a systemd user service (`~/.config/systemd/user/mobilecli-daemon.service`)
   - macOS: Generate a launchd plist (`~/Library/LaunchAgents/com.mobilecli.daemon.plist`)
   - Add `mobilecli install-service` and `mobilecli uninstall-service` commands
   - Setup wizard should offer to install the service

2. **Add daemon health check from mobile**
   - When the mobile app fails to connect, show a clear message: "Desktop daemon not running. Run `mobilecli` on your computer."
   - Current behavior: shows "disconnected" with no guidance

3. **Reset reconnect backoff on app foreground**
   - `useSync.ts:748-774` already reconnects on app resume, but doesn't reset `globalReconnectAttempts`
   - Add `globalReconnectAttempts = 0` before calling `connect()` in the app state change handler (line 763)

4. **Clean up stale PID files**
   - In `daemon.rs:is_running()`, if the PID file exists but the process is dead, delete the PID and port files
   - This prevents stale state after crashes or updates

---

## Issue #2: QR Code Auth Token

### Symptom
When scanning the QR code, it puts an auth token. The user doesn't want the auth token; it should just connect to the Tailscale IP. The auth token maybe shouldn't exist in settings at all.

### Root Cause Analysis

#### A. Dead code: Auth token is in `ConnectionInfo` but NEVER added to QR

In `cli/src/protocol.rs:534-535`, there is an **empty if-block** that extracts the auth_token but does nothing with it:

```rust
if let Some(token) = &self.auth_token {
    // EMPTY - token is not pushed to params
}
```

The QR code generated by `mobilecli pair` or `mobilecli setup` contains `mobilecli://host:port?device_id=UUID&device_name=HOSTNAME` but **no auth_token parameter**. Despite this, `main.rs:413` still passes `Some(config.auth_token)` to `ConnectionInfo`.

#### B. Mobile QR scanner extracts auth_token but never passes it forward

In `mobile/components/QRScanner.tsx:90`:
```typescript
const authToken = params.get('auth_token') || undefined;
```

The token is extracted from the URL params but **never included in the `onScan` callback result** (lines 101-108). The `QRScanResult` interface (lines 9-21) does not have an `authToken` field.

#### C. Settings screen explicitly clears auth token on QR scan

In `mobile/app/(tabs)/settings.tsx:293-295`:
```typescript
// Do not store pairing auth tokens from QR codes; direct URL/IP connections are supported.
setTempAuthToken('');
setAuthToken('');
```

#### D. BUT the auth token field is visible in the settings UI

Even though the QR scan clears it, the settings screen still shows an auth_token input field. This is confusing because:
- The daemon doesn't enforce auth tokens (since commit `9a1d449`)
- The QR code doesn't contain auth tokens (empty if-block in `to_compact_qr`)
- The settings code explicitly clears it on QR scan
- Yet the field is visible and editable, leading to user confusion

#### E. The `createDeviceFromQR` function accepts authToken but never receives one

`mobile/hooks/useDevices.ts:105-123` - The function signature accepts an optional `authToken` parameter, but settings.tsx only passes 3 arguments (line 278-282), never the auth token.

#### F. Daemon always generates an auth_token on startup

In `cli/src/daemon.rs:152-166`, `DaemonState::new()` loads or creates a config, which always has an auth_token (UUID). In `cli/src/setup.rs:42-43`, `Config::default()` generates `uuid::Uuid::new_v4()`. This token exists in `~/.mobilecli/config.json` even though it serves no purpose.

### Recommendations

1. **Remove the auth_token field from the settings UI (HIGH PRIORITY)**
   - It's not used, not enforced, and confuses users
   - Remove the TextInput for auth token in `settings.tsx`
   - Keep the internal plumbing for potential future use, but hide from users

2. **Clean up the dead code in `to_compact_qr()`**
   - Either remove the empty if-block (lines 534-535 in protocol.rs) entirely
   - Or if auth_token should be in the QR, actually add it to params

3. **Remove auth_token from Config if not needed**
   - If auth tokens are truly not enforced, stop generating them in `Config::default()`
   - Remove from `config.json` serialization
   - This reduces confusion in the codebase

4. **Add `authToken` to `QRScanResult` interface if it's ever needed**
   - Currently extracted but discarded in QRScanner.tsx:90
   - Either use it or remove the extraction

---

## Issue #3: Random Crashes

### Crash Log Analysis (Build 68)

**Crash summary:**
- **Device:** iPhone 17,4, iOS 26.2.1
- **Build:** 1.0.0 (68)
- **Time since launch:** ~2 seconds (launched 15:51:46, crashed 15:51:48)
- **Exception:** `EXC_CRASH (SIGABRT)` - Signal 6 Abort trap
- **Crashed thread:** Thread 1

#### Thread 0 (Main Thread) - Screen Navigation

```
11  MobileCLI  -[RNSScreen setViewToSnapshot] + 140 (RNSScreen.mm:1999)
12  MobileCLI  -[RNSScreenStackView unmountChildComponentView:index:] + 56 (RNSScreenStack.mm:1411)
13  React      RCTPerformMountInstructions(...) + 692 (RCTMountingManager.mm:97)
```

The main thread is performing a **React Native screen transition**. Specifically:
- A screen is being unmounted from the navigation stack (`unmountChildComponentView`)
- During unmount, `setViewToSnapshot` is called to capture the view state
- This is happening inside a React mounting transaction

#### Thread 1 (Crashed) - TurboModule Call

```
9   React  ObjCTurboModule::performVoidMethodInvocation(...) + 192 (RCTTurboModule.mm:441)
```

Thread 1 crashed calling a **TurboModule void method**. The Objective-C exception propagated up through `libc++abi` and caused a SIGABRT.

#### Thread 10 - StoreKit Activity

Thread 10 shows StoreKit framework calls, suggesting subscription/in-app purchase checks were running concurrently.

### Diagnosis

This is a **known react-native-screens crash pattern**. The crash occurs when:

1. A screen is being unmounted from the navigation stack
2. `setViewToSnapshot` tries to capture the current view for the transition animation
3. Simultaneously, a TurboModule call on a background thread fails (possibly because the view it references is being destroyed)
4. The Objective-C exception causes SIGABRT

**The 2-second-after-launch timing suggests this happens during initial navigation setup** - likely when the app navigates from a splash/loading state to the main tab navigator, or when the welcome modal triggers a navigation.

**Key version information:**
- `react-native-screens`: ~4.16.0
- `react-native`: 0.81.5
- `expo`: ~54.0.33

### Potential Triggers

1. **Welcome modal + tab navigation race condition**: The app checks `hasSeenWelcome` on mount and shows a modal. If settings aren't loaded yet (`isLoaded` is false), the navigation state might be unstable when the modal appears.

2. **QR scanner modal dismiss + Alert race**: Closing the QR scanner (`setShowQRScanner(false)`) triggers a re-render that unmounts the camera view. If an Alert fires simultaneously (via the double setTimeout in settings.tsx), the navigation stack gets corrupted.

3. **StoreKit concurrent access**: Thread 10 shows StoreKit activity. If a subscription check triggers a UI update while a screen transition is in progress, it can cause the snapshot crash.

4. **SecureStore async load race**: `useDevices.loadDevices()` and `useSettings` load from SecureStore asynchronously. If the data arrives while a navigation transition is in progress, state changes can trigger unmount during snapshot.

### Recommendations

1. **Update react-native-screens (HIGH PRIORITY)**
   - Version 4.16.0 has known crash bugs with `setViewToSnapshot` during unmount
   - Check for patches in 4.17+ or 4.18+
   - See: https://github.com/software-mansion/react-native-screens/issues

2. **Guard navigation during loading state**
   - In `app/(tabs)/index.tsx`, the component renders immediately even if `isLoaded` is false
   - Add a loading guard: don't render the full screen (or trigger modals) until both `settings.isLoaded` and `devicesLoaded` are true
   - This prevents navigation races during hydration

3. **Defer StoreKit checks**
   - If there's a paywall or subscription check on app launch, defer it until after the initial navigation is complete
   - Use `InteractionManager.runAfterInteractions()` or a delay

4. **Fix the QR scanner dismiss + Alert timing**
   - The double setTimeout in `settings.tsx:304-329` creates a 500ms window where the scanner is closing, the screen is transitioning, and an Alert fires simultaneously
   - This is the most likely trigger for the crash (see Issue #4 below)

5. **Add crash reporting with symbolication**
   - The crash log lacks symbolicated React Native frames
   - Add Sentry or Bugsnag for full stack traces including JS frames

---

## Issue #4: "Connection Successful" Dialog Stuck

### Symptom
After scanning QR code in setup, the popup says "Device Linked" (user calls it "connection successful"). Pressing "OK" / "View Sessions" doesn't dismiss it. App must be restarted.

### Root Cause Analysis

The code in `mobile/app/(tabs)/settings.tsx:297-329` has **severely broken control flow**:

```typescript
// Handle terminal session QR (from new CLI)
if (result.type === 'terminal') {
  const deviceLabel = result.deviceName || 'Device';
  const message = ...;

  setTimeout(() => {          // <-- OUTER setTimeout (250ms)
  setTimeout(() => {          // <-- INNER setTimeout (another 250ms, NESTED)
    Alert.alert(
      'Device Linked',
      message,
      [{
        text: 'View Sessions',
        onPress: () => router.push('/(tabs)'),
      }],
      { cancelable: false }   // <-- CANNOT dismiss by tapping outside
    );
  }, 250);                    // <-- end inner setTimeout
    return;                   // <-- returns from OUTER setTimeout callback, NOT from handleQRScan
  }                           // <-- closes if (result.type === 'terminal')

  // Non-terminal alert code STILL INSIDE outer setTimeout
  const typeLabel = ...;
  Alert.alert(
    'Device Linked',
    `${typeLabel} connection configured: ${result.url}`,
    [{ text: 'OK', style: 'default' }],
    { cancelable: true }
  );
}, 250);                      // <-- end outer setTimeout
```

#### Problems identified:

1. **Double nested `setTimeout`**: The terminal Alert is wrapped in TWO setTimeouts. Total delay before showing = 500ms. The outer setTimeout also contains the fallback (non-terminal) Alert code. This is clearly a merge/edit error.

2. **`cancelable: false`**: The terminal Alert cannot be dismissed by tapping outside. Only the "View Sessions" button can dismiss it.

3. **Navigation may fail silently**: The only dismiss action is `router.push('/(tabs)')`. If:
   - The user is already on the `(tabs)` route (they are - settings IS a tab)
   - Expo Router's `push()` doesn't navigate to the same route (it typically doesn't)
   - The navigation fails for any reason

   Then the Alert persists with no way to dismiss it. `cancelable: false` prevents tapping outside.

4. **Race condition with screen transitions**: The `setShowQRScanner(false)` on line 274 triggers a re-render that closes the camera modal. 250ms later (outer setTimeout), 250ms after that (inner setTimeout), the Alert fires. If the screen transition from QR scanner close is still animating at that point, the Alert may display on a corrupted view hierarchy, causing the react-native-screens crash from Issue #3.

5. **Two Alerts may fire simultaneously**: For `terminal` type connections, because of the broken brace structure, **both** the inner setTimeout Alert AND the non-terminal Alert will fire (the `return` only exits the outer setTimeout callback, and the `if` block closes before the non-terminal code). This means TWO Alert.alert() calls fire in rapid succession. React Native can only show one Alert at a time - the second one either queues behind the first or gets lost, potentially corrupting the Alert presentation state.

### Fix (Critical)

Replace the entire `handleQRScan` alert section (lines 297-329) with:

```typescript
// Handle terminal session QR (from new CLI)
if (result.type === 'terminal') {
  const deviceLabel = result.deviceName || 'Device';
  const message = result.sessionId
    ? `Linked to "${deviceLabel}". ${result.sessionName ? `Session "${result.sessionName}"` : 'View sessions'} available.`
    : `Linked to "${deviceLabel}". Ready to view sessions.`;

  setTimeout(() => {
    Alert.alert(
      'Device Linked',
      message,
      [
        { text: 'OK', style: 'cancel' },
        {
          text: 'View Sessions',
          onPress: () => router.push('/(tabs)'),
        },
      ],
      { cancelable: true }
    );
  }, 300);
  return;  // <-- return from handleQRScan, not just a callback
}

// Non-terminal types
const typeLabel = result.type === 'tailscale' ? 'Tailscale' : result.type === 'relay' ? 'Relay' : 'Direct';
setTimeout(() => {
  Alert.alert(
    'Device Linked',
    `${typeLabel} connection configured: ${result.url}`,
    [{ text: 'OK', style: 'default' }],
    { cancelable: true }
  );
}, 300);
```

Key changes:
- **Remove double setTimeout** - single 300ms delay is sufficient
- **Add `cancelable: true`** so users can tap outside to dismiss
- **Add an "OK" button** as a cancel-style button so there's always a way to dismiss
- **Move `return` outside the setTimeout** so it's actually in `handleQRScan` scope
- **Separate the terminal and non-terminal code paths** so they don't share a setTimeout callback
- **Use `router.replace` instead of `router.push`** if navigating to current tab (or just use `router.navigate`)

---

## Git History: Regression Analysis

### Critical Commits After Build 65/66

Build 65/66 shipped around Feb 1. These are the high-risk commits after that point:

| Date | Commit | Description | Risk |
|------|--------|-------------|------|
| Feb 10 | `aa17a1a` | Harden pairing/auth, filesystem security | **CRITICAL** |
| Feb 11 | `9a1d449` | Allow direct IP/Tailscale without QR token | **HIGH** |
| Feb 13 | `c36a22b` | Add attachment upload RPC | Medium |
| Feb 14 | `940ffd1` | Harden uploads, normalize PTY newlines | Medium |
| Feb 14 | `0531cdb` | Fix text/binary detection | Low |
| Feb 15 | `331d5c8` | Fix PTY newline normalization | Low |

### Commit `aa17a1a` (Feb 10) - The Big One

**27 files changed, +1911, -615 lines**. This commit:

1. **Added `auth_token` to `DaemonState`** - daemon now always has a token
2. **Added auth token enforcement** - initially REJECTED connections without matching token
3. **Gutted `qr.rs`** - removed `show_pairing_qr()`, `generate_connection_info()`, `get_local_ip()`, `display_qr()` (135 -> 18 lines)
4. **Added `auth_token` to `ConnectionInfo`** and `to_compact_qr()` format
5. **Removed `platform.rs`** entirely
6. **Removed session functions** from `session.rs` (`register_session`, `unregister_session`, `rename_session`)
7. **Removed `get_connection_ip()`** from `setup.rs`

### Commit `9a1d449` (Feb 11) - Partial Rollback

**7 files, +41/-34 lines**. Reversed the auth enforcement:
- Changed from hard-rejecting unauthenticated clients to just logging a warning
- Made auth_token explicitly optional in doc comments
- This is why the current code has the empty if-block in `to_compact_qr()` - the auth_token was removed from the QR but the struct field remained

### Protocol Evolution Timeline

| State | When | QR Content | Auth Enforcement |
|-------|------|------------|-----------------|
| Pre-Feb 10 (Build 65) | Before `aa17a1a` | `mobilecli://host:port?device_id=X&device_name=Y` | None |
| Feb 10 | `aa17a1a` | Added `auth_token=UUID` | **Hard reject on mismatch** |
| Feb 11+ (Build 68) | `9a1d449` | Token in struct but **empty if-block** = not in QR | Log-only, no rejection |

### What Was Stable at Build 65/66

Based on the commit gap (no commits Feb 1-10), build 65/66 had:
- Basic QR pairing with IP + device info
- No auth token
- Simple WebSocket accept (no config overrides)
- File system service with ENOTDIR fixes
- Functional `mobilecli setup` wizard

### What Broke After Build 65/66

1. **Auth token confusion** - Added then partially removed, leaving dead code
2. **QR module gutted** - Many helper functions removed in aa17a1a
3. **WebSocket config change** - `accept_async` -> `accept_async_with_config` in `940ffd1`
4. **Protocol additions** - `UploadFile`, new message types that old mobile builds won't recognize

---

## Architecture Notes

### Connection Flow (Mobile -> CLI)

```
Mobile App                         CLI Daemon
    |                                  |
    |-- WebSocket connect ------------>|  (ws://host:9847)
    |                                  |
    |-- { type: "hello",              |
    |     auth_token: "...",          |
    |     client_version: "0.1.0" }-->|
    |                                  |
    |<-- { type: "welcome",           |
    |      server_version: "...",     |
    |      authenticated: true,       |
    |      device_id: "...",          |
    |      device_name: "..." } ------|
    |                                  |
    |<-- { type: "sessions",          |
    |      sessions: [...] } ---------|
    |                                  |
    |-- { type: "subscribe",          |
    |     session_id: "..." } ------->|
    |                                  |
    |<-- { type: "pty_bytes",         |
    |      session_id: "...",         |
    |      data: "base64..." } -------|  (continuous)
```

### Key Files Reference

| File | Purpose |
|------|---------|
| `cli/src/main.rs` | CLI entry, daemon background start |
| `cli/src/daemon.rs` | WebSocket server, session routing |
| `cli/src/setup.rs` | Config, setup wizard, Tailscale |
| `cli/src/protocol.rs` | Message types, ConnectionInfo, QR encoding |
| `cli/src/qr.rs` | Terminal QR rendering |
| `cli/src/pty_wrapper.rs` | PTY spawn, streaming |
| `mobile/hooks/useSync.ts` | WebSocket lifecycle, reconnect |
| `mobile/hooks/useActiveConnection.ts` | URL/token resolution |
| `mobile/hooks/useDevices.ts` | Device storage (SecureStore) |
| `mobile/hooks/useSettings.ts` | Settings storage |
| `mobile/components/QRScanner.tsx` | QR parsing, multiple formats |
| `mobile/app/(tabs)/settings.tsx` | Settings UI, QR scan handler, **broken Alert** |
| `mobile/app/(tabs)/index.tsx` | Sessions list, connection status |
| `mobile/app/_layout.tsx` | Root layout, push notifications |

### Config File Location

- CLI config: `~/.mobilecli/config.json`
- Daemon PID: `~/.mobilecli/daemon.pid`
- Daemon port: `~/.mobilecli/daemon.port`
- Daemon log: `~/.mobilecli/daemon.log`

---

## Priority Summary

| Priority | Issue | Fix Complexity | Impact |
|----------|-------|----------------|--------|
| **P0** | Dialog stuck (Issue #4) | Easy - fix brace structure, add cancelable | App unusable after QR scan |
| **P0** | Random crashes (Issue #3) | Medium - update deps, fix races | App crashes on launch |
| **P1** | Auto-connect (Issue #1) | Medium - add daemon service, reset backoff | Poor UX, manual workaround exists |
| **P2** | Auth token UX (Issue #2) | Easy - hide field, clean dead code | Confusing but not blocking |
